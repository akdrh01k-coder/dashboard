# pages/2_ìœ„ì¹˜_ëª¨ë‹ˆí„°ë§_LiDAR.py
import time
import math
from typing import Tuple

import numpy as np
import requests
import streamlit as st
import matplotlib.pyplot as plt
import matplotlib
import matplotlib.font_manager as fm

# â”€â”€ í•œê¸€ í°íŠ¸ ìë™ ì„ íƒ
def _use_korean_font():
    candidates = ["Malgun Gothic", "MalgunGothic", "NanumGothic", "AppleGothic"]
    installed = {f.name for f in fm.fontManager.ttflist}
    for name in candidates:
        if name in installed:
            matplotlib.rcParams["font.family"] = name
            break
    matplotlib.rcParams["axes.unicode_minus"] = False
_use_korean_font()

st.header("ğŸ“¡ ìœ„ì¹˜ ëª¨ë‹ˆí„°ë§ â†’ LiDAR (ëª¨ë“œ ì„ íƒ)")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ì‚¬ì´ë“œë°”: ëª¨ë“œ/ì—°ê²°/í‘œì‹œì£¼ê¸° (ì‹¤ì œ ëª¨ë“œì—ì„œëŠ” ì„¼ì„œ íŒŒë¼ë¯¸í„°ë¥¼ ìˆ¨ê¹€)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
col = st.sidebar
mode = col.selectbox("ë°ì´í„° ì†ŒìŠ¤", ["ì‹¤ì œ LiDAR(ë¼ì¦ˆë² ë¦¬)", "ë”ë¯¸ ì‹œë®¬ë ˆì´í„°"])

API_BASE   = col.text_input("ì„¼ì„œ/ì œì–´ API ì£¼ì†Œ", "http://127.0.0.1:8000")
ENDPOINT   = col.text_input("ì—”ë“œí¬ì¸íŠ¸ ê²½ë¡œ", "/lidar/latest")
hz         = col.slider("í‘œì‹œ ì£¼ê¸°(Hz)", 1, 30, 10)
timeout_s  = col.slider("ìš”ì²­ íƒ€ì„ì•„ì›ƒ(s)", 0.2, 3.0, 1.0, 0.1)
run        = col.toggle("ì‹¤ì‹œê°„ í‘œì‹œ ì‹œì‘", value=False, key="lidar_run")

# ë”ë¯¸ ì „ìš© íŒŒë¼ë¯¸í„°(ì‹¤ì œ ëª¨ë“œì¼ ë• ê°ì¶¤)
if mode == "ë”ë¯¸ ì‹œë®¬ë ˆì´í„°":
    col.markdown("â€”")
    col.caption("ğŸ§ª ë”ë¯¸ íŒŒë¼ë¯¸í„°")
    points        = col.slider("ìŠ¤ìº” í•´ìƒë„(í¬ì¸íŠ¸ ìˆ˜)", 90, 720, 360, step=30)
    r_max         = col.slider("ìµœëŒ€ê±°ë¦¬ Rmax (m)", 5.0, 50.0, 12.0, 0.5)
    noise_sigma   = col.slider("ë…¸ì´ì¦ˆ Ïƒ (m)", 0.0, 0.5, 0.08, 0.01)
    dropout       = col.slider("ë“œë¡­ì•„ì›ƒ ë¹„ìœ¨(%)", 0, 50, 6, help="ì„¼ì„œ ë¯¸ë°˜ì‚¬/ê³¼ê±°ë¦¬ ì§€ì  ë¹„ìœ¨")
    show_obstacles= col.checkbox("ì´ë™ ë¬¼ì²´(ì¥ì• ë¬¼) í‘œí˜„", True)
else:
    col.info("ì‹¤ì œ ëª¨ë“œì—ì„œëŠ” ì„¼ì„œ ì£¼ê¸°/í•´ìƒë„ ë“±ì€ ë¼ì¦ˆë² ë¦¬ ìª½ ì„¤ì •ì„ ê·¸ëŒ€ë¡œ ë”°ë¦…ë‹ˆë‹¤.")

interval = 1.0 / hz

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ë”ë¯¸ ìŠ¤ìº” ìƒì„±ê¸°
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def simulate_lidar_scan(t: float, n: int, rmax: float, sigma: float,
                        dropout_rate: float, moving_obstacles: bool) -> Tuple[np.ndarray, np.ndarray]:
    theta = np.linspace(0, 2*np.pi, n, endpoint=False)
    base = 6.5 + 0.9*np.cos(theta - 0.3) + 0.6*np.cos(2*theta + 0.6) + 0.25*np.sin(3*theta + 0.5*t)
    r = base + np.random.normal(0.0, sigma, size=n)
    if moving_obstacles:
        ang_a = (0.8*t) % (2*np.pi); idx_a = int(ang_a / (2*np.pi) * n)
        for k in range(-2, 3): r[(idx_a + k) % n] = 1.6 + 0.2*np.random.randn()
        ang_b = (0.8*t + np.pi) % (2*np.pi); idx_b = int(ang_b / (2*np.pi) * n)
        for k in range(-3, 4): r[(idx_b + k) % n] = 3.0 + 0.2*np.random.randn()
    if dropout_rate > 0:
        mask = np.random.rand(n) < (dropout_rate / 100.0)
        r[mask] = np.nan
    r = np.clip(r, 0.2, rmax)
    return theta, r

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ì‹¤ì œ í”„ë ˆì„ ì½ê¸° (FastAPI: GET {API_BASE}{ENDPOINT})
# ì‘ë‹µ ì˜ˆì‹œ(ë‘˜ ì¤‘ í•˜ë‚˜ í—ˆìš©):
# 1) {"ts": 1724660000.12, "angles":[deg...], "ranges":[m...]}  # ê°ë„=ë„
# 2) {"ts": ..., "theta":[rad...], "r":[m...]}                  # ê°ë„=ë¼ë””ì•ˆ
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def fetch_real_frame() -> Tuple[np.ndarray, np.ndarray, float]:
    url = f"{API_BASE.rstrip('/')}{ENDPOINT}"
    r = requests.get(url, timeout=timeout_s)
    r.raise_for_status()
    j = r.json()
    ts = j.get("ts", time.time())

    if "angles" in j and "ranges" in j:  # degrees + ranges
        ang = np.array(j["angles"], dtype=float)
        rng = np.array(j["ranges"], dtype=float)
        theta = np.deg2rad(ang)
    elif "theta" in j and "r" in j:      # radians + ranges
        theta = np.array(j["theta"], dtype=float)
        rng   = np.array(j["r"], dtype=float)
    else:
        raise ValueError("ì‘ë‹µ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤. (angles/ranges ë˜ëŠ” theta/r í•„ìš”)")
    return theta, rng, ts

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# í´ë¼ í”Œë¡¯
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def render_polar(theta: np.ndarray, r: np.ndarray, rmax_plot: float, title: str):
    fig = plt.figure(figsize=(6.2, 6.2))
    ax = fig.add_subplot(111, projection="polar")
    ax.set_theta_zero_location("E"); ax.set_theta_direction(-1)
    ax.set_rmax(rmax_plot)
    ax.grid(True, alpha=0.35)
    ax.set_rticks([rmax_plot*0.25, rmax_plot*0.5, rmax_plot*0.75, rmax_plot])
    ax.scatter(theta, r, s=9, c="#1f77b4", alpha=0.9)
    ax.set_title(title, pad=20, fontsize=14, fontweight="bold")
    st.pyplot(fig, clear_figure=True); plt.close(fig)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# í‘œì‹œ ë£¨í‹´
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
placeholder = st.empty()
stats = st.empty()

def draw_once():
    if mode == "ì‹¤ì œ LiDAR(ë¼ì¦ˆë² ë¦¬)":
        try:
            th, rr, ts = fetch_real_frame()
        except requests.exceptions.HTTPError as e:
            st.error(f"ì„¼ì„œ/ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: {e} â€” {API_BASE}{ENDPOINT}")
            raise
        except Exception as e:
            st.error(f"ì„¼ì„œ/ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: {e}")
            raise
        rmax_plot = (np.nanmax(rr) * 1.1) if np.isfinite(rr).any() else 10.0
        render_polar(th, rr, rmax_plot, "ì‹¤ì‹œê°„ LiDAR ìŠ¤ìº” (ì‹¤ì œ)")
        pts_cnt = int(np.count_nonzero(np.isfinite(rr)))
        stats.caption(f"í”„ë ˆì„ ì‹œê°: {time.strftime('%H:%M:%S', time.localtime(ts))} | pts={pts_cnt}, Rmaxâ‰ˆ{rmax_plot:.2f}m")
    else:
        t = time.time()
        th, rr = simulate_lidar_scan(t, points, r_max, noise_sigma, dropout, show_obstacles)
        render_polar(th, rr, r_max, "ì‹¤ì‹œê°„ LiDAR ìŠ¤ìº” (ë”ë¯¸)")
        stats.caption(f"í”„ë ˆì„ ì‹œê°: {time.strftime('%H:%M:%S')} | pts={points}, Rmax={r_max:.1f}m, Ïƒ={noise_sigma:.2f}m, dropout={dropout}%")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ëŸ°íƒ€ì„ ì œì–´
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if "lidar_running" not in st.session_state:
    st.session_state.lidar_running = False
st.session_state.lidar_running = run

if st.session_state.lidar_running:
    with placeholder.container():
        draw_once()
    while st.session_state.lidar_running:
        time.sleep(interval)
        st.session_state.lidar_running = st.session_state.get("lidar_run", run)
        with placeholder.container():
            draw_once()
else:
    with placeholder.container():
        draw_once()

# ì•ˆë‚´
if mode == "ì‹¤ì œ LiDAR(ë¼ì¦ˆë² ë¦¬)":
    st.caption("â€» FastAPIì—ì„œ /lidar/latest(ì—”ë“œí¬ì¸íŠ¸ ìˆ˜ì • ê°€ëŠ¥)ê°€ ìµœê·¼ ìŠ¤ìº”ì„ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.")
else:
    st.caption("â€» ì‹¤ì‚¬ìš© ì‹œ: ë”ë¯¸ ëŒ€ì‹  DB/ì‹œë¦¬ì–¼ì—ì„œ ìµœì‹  ìŠ¤ìº”ì„ ì½ì–´ ì£¼ì…í•˜ì„¸ìš”.")
