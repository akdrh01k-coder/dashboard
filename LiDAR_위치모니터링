# pages/2_위치_모니터링_LiDAR.py
import time
import math
from typing import Tuple

import numpy as np
import requests
import streamlit as st
import matplotlib.pyplot as plt
import matplotlib
import matplotlib.font_manager as fm

# ── 한글 폰트 자동 선택
def _use_korean_font():
    candidates = ["Malgun Gothic", "MalgunGothic", "NanumGothic", "AppleGothic"]
    installed = {f.name for f in fm.fontManager.ttflist}
    for name in candidates:
        if name in installed:
            matplotlib.rcParams["font.family"] = name
            break
    matplotlib.rcParams["axes.unicode_minus"] = False
_use_korean_font()

st.header("📡 위치 모니터링 → LiDAR (모드 선택)")

# ─────────────────────────────────────────────
# 사이드바: 모드/연결/표시주기 (실제 모드에서는 센서 파라미터를 숨김)
# ─────────────────────────────────────────────
col = st.sidebar
mode = col.selectbox("데이터 소스", ["실제 LiDAR(라즈베리)", "더미 시뮬레이터"])

API_BASE   = col.text_input("센서/제어 API 주소", "http://127.0.0.1:8000")
ENDPOINT   = col.text_input("엔드포인트 경로", "/lidar/latest")
hz         = col.slider("표시 주기(Hz)", 1, 30, 10)
timeout_s  = col.slider("요청 타임아웃(s)", 0.2, 3.0, 1.0, 0.1)
run        = col.toggle("실시간 표시 시작", value=False, key="lidar_run")

# 더미 전용 파라미터(실제 모드일 땐 감춤)
if mode == "더미 시뮬레이터":
    col.markdown("—")
    col.caption("🧪 더미 파라미터")
    points        = col.slider("스캔 해상도(포인트 수)", 90, 720, 360, step=30)
    r_max         = col.slider("최대거리 Rmax (m)", 5.0, 50.0, 12.0, 0.5)
    noise_sigma   = col.slider("노이즈 σ (m)", 0.0, 0.5, 0.08, 0.01)
    dropout       = col.slider("드롭아웃 비율(%)", 0, 50, 6, help="센서 미반사/과거리 지점 비율")
    show_obstacles= col.checkbox("이동 물체(장애물) 표현", True)
else:
    col.info("실제 모드에서는 센서 주기/해상도 등은 라즈베리 쪽 설정을 그대로 따릅니다.")

interval = 1.0 / hz

# ─────────────────────────────────────────────
# 더미 스캔 생성기
# ─────────────────────────────────────────────
def simulate_lidar_scan(t: float, n: int, rmax: float, sigma: float,
                        dropout_rate: float, moving_obstacles: bool) -> Tuple[np.ndarray, np.ndarray]:
    theta = np.linspace(0, 2*np.pi, n, endpoint=False)
    base = 6.5 + 0.9*np.cos(theta - 0.3) + 0.6*np.cos(2*theta + 0.6) + 0.25*np.sin(3*theta + 0.5*t)
    r = base + np.random.normal(0.0, sigma, size=n)
    if moving_obstacles:
        ang_a = (0.8*t) % (2*np.pi); idx_a = int(ang_a / (2*np.pi) * n)
        for k in range(-2, 3): r[(idx_a + k) % n] = 1.6 + 0.2*np.random.randn()
        ang_b = (0.8*t + np.pi) % (2*np.pi); idx_b = int(ang_b / (2*np.pi) * n)
        for k in range(-3, 4): r[(idx_b + k) % n] = 3.0 + 0.2*np.random.randn()
    if dropout_rate > 0:
        mask = np.random.rand(n) < (dropout_rate / 100.0)
        r[mask] = np.nan
    r = np.clip(r, 0.2, rmax)
    return theta, r

# ─────────────────────────────────────────────
# 실제 프레임 읽기 (FastAPI: GET {API_BASE}{ENDPOINT})
# 응답 예시(둘 중 하나 허용):
# 1) {"ts": 1724660000.12, "angles":[deg...], "ranges":[m...]}  # 각도=도
# 2) {"ts": ..., "theta":[rad...], "r":[m...]}                  # 각도=라디안
# ─────────────────────────────────────────────
def fetch_real_frame() -> Tuple[np.ndarray, np.ndarray, float]:
    url = f"{API_BASE.rstrip('/')}{ENDPOINT}"
    r = requests.get(url, timeout=timeout_s)
    r.raise_for_status()
    j = r.json()
    ts = j.get("ts", time.time())

    if "angles" in j and "ranges" in j:  # degrees + ranges
        ang = np.array(j["angles"], dtype=float)
        rng = np.array(j["ranges"], dtype=float)
        theta = np.deg2rad(ang)
    elif "theta" in j and "r" in j:      # radians + ranges
        theta = np.array(j["theta"], dtype=float)
        rng   = np.array(j["r"], dtype=float)
    else:
        raise ValueError("응답 형식이 잘못되었습니다. (angles/ranges 또는 theta/r 필요)")
    return theta, rng, ts

# ─────────────────────────────────────────────
# 폴라 플롯
# ─────────────────────────────────────────────
def render_polar(theta: np.ndarray, r: np.ndarray, rmax_plot: float, title: str):
    fig = plt.figure(figsize=(6.2, 6.2))
    ax = fig.add_subplot(111, projection="polar")
    ax.set_theta_zero_location("E"); ax.set_theta_direction(-1)
    ax.set_rmax(rmax_plot)
    ax.grid(True, alpha=0.35)
    ax.set_rticks([rmax_plot*0.25, rmax_plot*0.5, rmax_plot*0.75, rmax_plot])
    ax.scatter(theta, r, s=9, c="#1f77b4", alpha=0.9)
    ax.set_title(title, pad=20, fontsize=14, fontweight="bold")
    st.pyplot(fig, clear_figure=True); plt.close(fig)

# ─────────────────────────────────────────────
# 표시 루틴
# ─────────────────────────────────────────────
placeholder = st.empty()
stats = st.empty()

def draw_once():
    if mode == "실제 LiDAR(라즈베리)":
        try:
            th, rr, ts = fetch_real_frame()
        except requests.exceptions.HTTPError as e:
            st.error(f"센서/네트워크 오류: {e} — {API_BASE}{ENDPOINT}")
            raise
        except Exception as e:
            st.error(f"센서/네트워크 오류: {e}")
            raise
        rmax_plot = (np.nanmax(rr) * 1.1) if np.isfinite(rr).any() else 10.0
        render_polar(th, rr, rmax_plot, "실시간 LiDAR 스캔 (실제)")
        pts_cnt = int(np.count_nonzero(np.isfinite(rr)))
        stats.caption(f"프레임 시각: {time.strftime('%H:%M:%S', time.localtime(ts))} | pts={pts_cnt}, Rmax≈{rmax_plot:.2f}m")
    else:
        t = time.time()
        th, rr = simulate_lidar_scan(t, points, r_max, noise_sigma, dropout, show_obstacles)
        render_polar(th, rr, r_max, "실시간 LiDAR 스캔 (더미)")
        stats.caption(f"프레임 시각: {time.strftime('%H:%M:%S')} | pts={points}, Rmax={r_max:.1f}m, σ={noise_sigma:.2f}m, dropout={dropout}%")

# ─────────────────────────────────────────────
# 런타임 제어
# ─────────────────────────────────────────────
if "lidar_running" not in st.session_state:
    st.session_state.lidar_running = False
st.session_state.lidar_running = run

if st.session_state.lidar_running:
    with placeholder.container():
        draw_once()
    while st.session_state.lidar_running:
        time.sleep(interval)
        st.session_state.lidar_running = st.session_state.get("lidar_run", run)
        with placeholder.container():
            draw_once()
else:
    with placeholder.container():
        draw_once()

# 안내
if mode == "실제 LiDAR(라즈베리)":
    st.caption("※ FastAPI에서 /lidar/latest(엔드포인트 수정 가능)가 최근 스캔을 반환해야 합니다.")
else:
    st.caption("※ 실사용 시: 더미 대신 DB/시리얼에서 최신 스캔을 읽어 주입하세요.")
